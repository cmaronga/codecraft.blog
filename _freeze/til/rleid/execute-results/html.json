{
  "hash": "bcdf68f436dd879244ded33cbd1f3b73",
  "result": {
    "markdown": "---\ntitle: \"data.table::rleid() is pretty cool!\"\ndate: 2022-11-27\n---\n\n\nLonger example on [QB Starts](https://gist.github.com/jthomasmock/f4264a372904a9a8b528a61adce51509)\n\n## Create a dataframe\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'ggplot2' was built under R version 4.3.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(magrittr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'magrittr'\n\nThe following object is masked from 'package:purrr':\n\n    set_names\n\nThe following object is masked from 'package:tidyr':\n\n    extract\n```\n:::\n\n```{.r .cell-code}\nlibrary(data.table)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'data.table'\n\nThe following objects are masked from 'package:lubridate':\n\n    hour, isoweek, mday, minute, month, quarter, second, wday, week,\n    yday, year\n\nThe following objects are masked from 'package:dplyr':\n\n    between, first, last\n\nThe following object is masked from 'package:purrr':\n\n    transpose\n```\n:::\n\n```{.r .cell-code}\n# create a df of\"streaks\" or repeats\nex_df <- tibble(\n  x = c(\"a\", \"a\", rep(\"b\", 3), rep(\"a\", 5)),\n  num = 1:10\n) \n\n# print the data\nex_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 2\n   x       num\n   <chr> <int>\n 1 a         1\n 2 a         2\n 3 b         3\n 4 b         4\n 5 b         5\n 6 a         6\n 7 a         7\n 8 a         8\n 9 a         9\n10 a        10\n```\n:::\n:::\n\n\n## Example of rle or run-length encoding\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# rle or run-length encoding\n# summarizes a vector into the length of each repeat\n# and the value that is repeated\n# technically this is a form of recoverable data compression\n# IE you end up with fewer bytes but it tells you what a long vector\n# could be, and can be recreated\n\n# this can be read as the betters a, b, a\n# where the first a is repeated 2x\n# the b is repeated 3x\n# the next a is repeated 5x\nrle(ex_df$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRun Length Encoding\n  lengths: int [1:3] 2 3 5\n  values : chr [1:3] \"a\" \"b\" \"a\"\n```\n:::\n:::\n\n\n## Example of rleid\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# rleid() generates the ids or repeated group of equal length\n# to the original vector\n\nex_df$x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"a\" \"a\" \"b\" \"b\" \"b\" \"a\" \"a\" \"a\" \"a\" \"a\"\n```\n:::\n\n```{.r .cell-code}\ndata.table::rleid(ex_df$x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 2 2 2 3 3 3 3 3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# it can be used on a vector, in a dataframe, in a datatable or a tibble\n# note that it can be used within mutate() since it returns\n# a vector of equal length, ie the number of rows is not changed\nex_df %>% \n  mutate(rleid = data.table::rleid(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 3\n   x       num rleid\n   <chr> <int> <int>\n 1 a         1     1\n 2 a         2     1\n 3 b         3     2\n 4 b         4     2\n 5 b         5     2\n 6 a         6     3\n 7 a         7     3\n 8 a         8     3\n 9 a         9     3\n10 a        10     3\n```\n:::\n:::\n\n\n## rle is a summary function\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# note that rle() is a _summary_ function, and generates fewer rows\nex_df %>% \n  summarize(lengths = rle(x)$lengths,\n            values =rle(x)$values)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  lengths values\n    <int> <chr> \n1       2 a     \n2       3 b     \n3       5 a     \n```\n:::\n:::\n\n\n## Recover the original data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# we can create a summary\n# and then recover the original data\nfinal_df <- ex_df %>% \n  summarize(\n    lengths = rle(x)$lengths,\n    values =rle(x)$values\n    ) %T>% print() %>% \n  summarize(\n    x = rep(values, times=lengths),\n    num = 1:sum(lengths)\n    )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  lengths values\n    <int> <chr> \n1       2 a     \n2       3 b     \n3       5 a     \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}